项目名称：WebRTC PCDN 级联直播演示（单主播 + 多观众）
1. 项目背景与目标
背景： 传统的直播方案中，主播推流到服务器，服务器分发给所有观众。当观众数量庞大时，服务器的带宽成本极高。
目标： 实现一个基于浏览器的纯Web端PCDN演示Demo。在该Demo中，只有一个主播推流，所有观众加入同一个“房间”。系统将观众组织成树状级联结构，观众不仅从上级节点接收流，同时将自己收到的流转发给下级观众，从而减少源站（主播）的带宽消耗。

2. 核心业务流程（逻辑描述）
为了简化演示，我们采用基于房间的管理策略，将主播视为根节点。

创建房间（主播端）：

主播点击“开始直播”，创建房间，获取自己的本地音视频流。

主播作为P2P网络的源节点（Root Peer）。

观众加入（观众端）：

观众输入房间ID，点击“加入观看”。

信令服务器维护房间内所有对等端的列表。

级联分发策略（核心逻辑）：

当新观众加入时，他不直接从主播拉流。

逻辑： 系统寻找一个最适合的“父节点”。

优先级 1：主播（如果主播的连接数未满）。

优先级 2：已经稳定播放的观众（这些观众既在播放，同时具备上传能力）。

简单策略： 为了演示，我们可以设定每个节点的最大分发数（扇出数）为 2 或 3。

如果主播已经有 2 个下级，第 3 个观众会自动连接到第一个观众的节点下，以此类推，形成一个逻辑树。

级联流转发：

观众 A 连接到主播，获得流。

观众 B 连接到主播，获得流。

观众 C 加入时，如果主播已达上限，观众 C 连接到观众 A，观众 A 将收到的流通过另一个 WebRTC 连接转发给观众 C。

观众 D 加入时，如果主播和观众 A 都已满，观众 D 连接到观众 B，以此类推。

3. 功能需求细节
3.1 信令服务器（辅助协调）

功能： 负责房间管理、Peer 连接握手（交换 SDP 和 ICE Candidate）。

接口/事件：

joinRoom(roomId, peerId)：加入房间。

leaveRoom(roomId, peerId)：离开房间。

getPeerList(roomId)：获取当前房间的所有 Peer。

relaySignal(data)：转发 WebRTC 信令（offer/answer/candidate）。

3.2 主播端（Publisher）

UI：包含“开始直播”按钮，视频预览窗口。

逻辑：

获取 getUserMedia。

连接到信令服务器，注册为主播。

维护一个计数器，记录当前直接连接的下级观众数量（扇出数）。

3.3 观众端（Subscriber/Repeater）

UI：包含“加入房间”输入框，视频播放窗口。列表显示当前网络拓扑（可选）。

逻辑：

加入房间后，从信令服务器获取 Peer 列表。

父节点选择算法（JavaScript 伪代码逻辑）：

javascript
function selectParent(allPeers, maxFanout = 2) {
    // 1. 过滤掉自己
    // 2. 检查主播(Publisher)当前的连接数是否 < maxFanout
    // 3. 如果主播满了，遍历观众列表，找到那些“当前子节点数 < maxFanout”的观众（这些观众既在播放，又有空位转发）
    // 4. 返回找到的父节点ID
}
与父节点建立 WebRTC 连接：作为 PeerConnection 的接收端，拉取流。

关键： 当该观众成功播放后，他需要将自己标记为“可转发节点”，并准备接受其他观众的连接（作为新的父节点）。

当有下级观众连接他时，他需要创建新的 PeerConnection（作为发送端），将本地已经在播放的 MediaStreamTrack 通过 addTransceiver 或 addTrack 转发给下级。

4. 用户界面描述（线框图概念）
顶部： 标题 “WebRTC PCDN 级联演示”。

左侧（主播区域）：

一个大视频框（显示主播画面）。

按钮：“🎥 开始直播”。

状态显示：“当前直连观众数：X”。

右侧（观众区域）：

输入框：“房间号”，按钮：“👀 加入观看”。

下方 Grid 网格，展示所有观众的视频画面（包括通过级联转发的）。

小提示：可以在每个观众画面下方标注“连接自：XXX”，以验证级联效果。

5. 技术栈建议（给kiro的参考）
前端框架： Vue 3 或 React（简单一点直接用 HTML + JavaScript 也行）。

WebRTC 库： 建议直接使用原生 WebRTC API（RTCPeerConnection）以便理解底层，或者使用简单的封装库如 peerjs（但 peerjs 默认是网格，需要修改策略）。

信令与通信： 可以使用 Node.js + Socket.io（或者直接用一个简单的 WebSocket 服务器）。

STUN/TURN： 需要配置公共的 STUN 服务器（如 Google 的 stun:stun.l.google.com:19302）以处理 NAT 穿透。Demo 环境可以不配置 TURN。

6. 验收标准
基础功能： 主播能成功推流，观众能成功看到画面。

级联验证：

打开一个主播页（Chrome）。

打开第一个观众页（Chrome 无痕模式 或 新浏览器），应直接连接主播。

打开第二个观众页，也应直接连接主播（假设扇出数=2，此时主播满）。

打开第三个观众页，此时应观察不到主播带宽明显上涨，但观众能看到画面。它应该连接到了第一个观众。

在 Network 面板（chrome://webrtc-internals）中，验证第三个观众的 “远程候选人” 地址是第一个观众的地址，而不是主播的地址。

动态退出： 如果作为父节点的观众（如观众1）退出，其下级节点（观众3）应能自动重新选择父节点（如观众2），并恢复播放（断线重连逻辑，高级功能，第一期可以先不做，或者简化处理）。

7. 注意事项（坑点提醒）
流转发： 在转发时，必须确保将接收到的 MediaStream 中的 Track 通过 addTrack 添加到发往下级的 RTCPeerConnection 中，而不是直接传递整个 MediaStream 对象。

多连接管理： 一个观众可能同时扮演两个角色：作为子节点接收流，作为父节点发送流。需要维护两个或更多的 RTCPeerConnection 实例。

视频/音频编码： 为了节省带宽，建议在转发时保持相同的编解码器，避免重编码（浏览器默认不支持转码，直接转发流是最高效的）。